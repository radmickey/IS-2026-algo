## Забор
Как известно, красить забор Тому Сойеру помогали многочисленные друзья. 
Каждый друг покрасил неcколько подряд идущих досок, при этом какие-то доски могли быть покрашены несколько раз, 
а какие-то доски могли остаться непокрашенными. 
Определите общее количество покрашенных досок.

### Входные данные
В первой строке содержится натуральное число n – количество друзей Тома Сойера (1 ≤ n ≤ 10^5). 
Далее идет n пар целых неотрицательных чисел – номер (от начала забора) доски, 
с которой друг начал красить забор и номер доски, на которой он закончил покраску. 
Каждый друг покрасил непрерывный участок забора, включая две заданные доски. 
Номера досок – целые числа от 1 до 10^9.
### Выходные данные
Программа должна вывести единственное число – суммарное количество покрашенных досок.

#### STDIN
```
3
1 2
3 4
2 3
```
#### STDOUT
```
4
```

### Примечание
Это задача на использование сортировок, поэтому при её решении запрещено использовать структуры данных, 
помогающие искать элементы в неупорядоченных наборах (сеты, мапы, хеш-таблицы, деревья поиска и прочие).

### Решение (Python)
```
def QuickSort(a):
    if len(a) == 0:
        return a
    
    b = a[len(a) // 2]
    al = []
    ar = []
    for i in range(len(a)):
        if (i != len(a) // 2):
            if a[i] <= b:
                al.append(a[i])
            else:
                ar.append(a[i])
    
    return QuickSort(al) + [b] + QuickSort(ar)



n = int(input())
c = []
for i in range(n):
    a, b = map(int,input().split())
    c.append([a,b])
c = QuickSort(c)
mi, ma = c[0]
k = 0
for i in range(1,n):
    if c[i][1] > ma :
        if c[i][0] <= ma :
            ma = c[i][1]
        else :
            k += ma - mi + 1
            mi, ma = c[i]
k += ma - mi + 1
print(k)
```
